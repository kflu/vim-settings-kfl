" ###################################################################
" # vimrc file
" # by Kefei Lu
" # modified from the default vimrc file.
" # Updated: 2009.10.18
" ###################################################################
"
" To use it, copy it to
"     for Unix and OS/2:  ~/.vimrc
"          for Amiga:  s:.vimrc
"  for MS-DOS and Win32:  $VIM\_vimrc
"        for OpenVMS:  sys$login:.vimrc

" When started as "evim", evim.vim will already have done these settings.

" ------------------------- VUNDLE SETUP -------------------------
set nocompatible " be iMproved, required
filetype off " required

" set the runtime path to include Vundle and initialize
" vim-settings-kfl should git clone Vundle.vim into ~/vundle
set rtp+=~/vundle/Vundle.vim
call vundle#begin('~/vundle') " install plugins into ~/vundle

Plugin 'gmarik/Vundle.vim'

Plugin 'majutsushi/tagbar'
Plugin 'puzzl3r/vim-mark'
Plugin 'Raimondi/delimitMate'
Plugin 'tpope/vim-surround'

Plugin 'bling/vim-airline'
Plugin 'scrooloose/nerdtree'
Plugin 'scrooloose/syntastic'
Plugin 'tpope/vim-commentary'
Plugin 'nathanaelkane/vim-indent-guides'

" ----- snipmate, snippets and the dependencies -----
Plugin 'garbas/vim-snipmate' " the main snipmate plugin
Plugin 'honza/vim-snippets' " snippets for snipmate
" Dependencies
Plugin 'marcweber/vim-addon-mw-utils'
Plugin 'tomtom/tlib_vim'

" ----- language support -----
Plugin 'kchmck/vim-coffee-script'
Plugin 'Windows-PowerShell-Syntax-Plugin'
" Disable csharp as it errors when running under console (vim)
" Plugin 'OrangeT/vim-csharp'

" ----- Themes -----
Plugin 'sickill/vim-monokai'
Plugin 'altercation/vim-colors-solarized'

call vundle#end()            " required
filetype plugin indent on    " required
" ------------------------- VUNDLE SETUP -------------------------

" ------------------------- EXAMPLE SETTINGS -------------------------
if v:progname =~? "evim"
    finish
endif
set nocompatible

" allow backspacing over everything in insert mode
set backspace=indent,eol,start

if has("vms")
    set nobackup        " do not keep a backup file, use versions instead
else
    set backup 	      " keep a backup file
endif
set history=50        " keep 50 lines of command line history
set ruler        " show the cursor position all the time
set showcmd        " display incomplete commands
set incsearch        " do incremental searching

" Don't use Ex mode, use Q for formatting
map Q gq

" In many terminal emulators the mouse works just fine, thus enable it.
set mouse=a

if &t_Co > 2 || has("gui_running")
    syntax on
    set hlsearch
endif

if has("autocmd")

    " Enable file type detection.
    " Use the default filetype settings, so that mail gets 'tw' set to 72,
    " 'cindent' is on in C files, etc.
    " Also load indent files, to automatically do language-dependent indenting.
    filetype plugin indent on

    " Put these in an autocmd group, so that we can delete them easily.
    augroup vimrcEx
        au!

        autocmd FileType text setlocal textwidth=78

        " When editing a file, always jump to the last known cursor position.
        " Don't do it when the position is invalid or when inside an event handler
        " (happens when dropping a file on gvim).
        autocmd BufReadPost *
                    \ if line("'\"") > 0 && line("'\"") <= line("$") |
                    \   exe "normal! g`\"" |
                    \ endif

    augroup END

else

    set autoindent        " always set autoindenting on

endif " has("autocmd")

" Convenient command to see the difference between the current buffer and the
" file it was loaded from, thus the changes you made.
command! DiffOrig vert new | set bt=nofile | r # | 0d_ | diffthis
            \ | wincmd p | diffthis
" ------------------------- EXAMPLE SETTINGS -------------------------

" ==============================
"  MY SETTINGS
" ==============================
function s:IsWindows()
    return has("win16") || has("win32") || has("win64") || has("win95")
endfunction

function s:SetFontWindows()
    set guifont=Bitstream_Vera_Sans_Mono:h9,
                \Monaco:h9,
                \Consolas:h9,
                \Lucida_Console:h9,
                \Courier_New:h9,
endfunction

function s:SetFontUnix()
    set guifont=Monospace\ 9,
endfunction

function s:ConfigureFont()
    if s:IsWindows()
        call s:SetFontWindows()
    else
        call s:SetFontUnix()
    endif

    set guifontwide=Yahei_Mono:h10:cGB2312,SimHei
    call s:MapFontChanges()
endfunction

" Change font size in 'guifont'
"   size:
"       '+'/'-':    increase/descrease font size
"       else:       Set font size to a:size (0 to default size)
"
"   This function will convert the fonts defined in 'guifont' to other font
"   sizes. Currently font size don't check if it gets to zero or minus.
function s:ChangeFontSize(size)
    if has("gui_running")
        if a:size == '+'
            let eval_str = '\=eval(submatch(0)+1)'
        elseif a:size == '-'
            let eval_str = '\=eval(submatch(0)-1)'
        else
            let eval_str = str2nr(a:size)
        endif

        let fontList = split(&guifont, ',')
        let fontList2 = []

        for font in fontList
            call add( fontList2, substitute(font, '\d\+', eval_str, '') )
        endfor
        let &guifont = join( fontList2, ',' )
    endif
endfunction

function s:MapFontChanges()
    if has("gui_running")
        map <Leader>= :<C-U>
                    \for i in range(v:count1)<bar>
                    \   call <SID>ChangeFontSize('+')<bar>
                    \endfor<CR>

        map <Leader>- :<C-U>
                    \for i in range(v:count1)<bar>
                    \   call <SID>ChangeFontSize('-')<bar>
                    \endfor<CR>

        map <Leader>0 :<C-U>call <SID>ChangeFontSize(0)<CR>
    endif
endfunction

" Search tag files in the following locations
" for "tags" 8 lvls upward
function s:ConfigureTags()
    set tags=
                \tags,
                \../tags,
                \../../tags,
                \../../../tags,
                \../../../../tags,
                \../../../../../tags,
                \../../../../../../tags,
                \../../../../../../../tags,
                \../../../../../../../../tags,
                \/usr/include/tags,

    "       include tag files from $HOME/tags
    let tagfiles = glob( "$HOME/tags/**/*" )
    let &tags = &tags . ',' . substitute(tagfiles, "\n", ",", "g")
endfunction

" C# settings
function s:ConfigureCSharp()

endfunction " s:ConfigureCSharp

function s:ConfigurePython()
    set sw=4 ts=4 smarttab expandtab autoindent
    " For python doc string (triple quotes), see
    " https://github.com/Raimondi/delimitMate/issues/55
    let b:delimitMate_nesting_quotes = ['"', "'"]
endfunction

" latex-suite settings
function s:ConfigureTex()
    " IMPORTANT: win32 users will need to have 'shellslash' set so that latex
    " can be called correctly.
    set shellslash

    " IMPORTANT: grep will sometimes skip displaying the file name if you
    " search in a singe file. This will confuse Latex-Suite. Set your grep
    " program to always generate a file-name.
    set grepprg=grep\ -nH\ $*

    " This considers ":" in the keywords when search using C-N, C-P Useful in
    " latex when input sec:xxx
    set iskeyword+=:

    " OPTIONAL: This enables automatic indentation as you type.
    filetype indent on

    " OPTIONAL: Starting with Vim 7, the filetype of empty .tex files defaults to
    " 'plaintex' instead of 'tex', which results in vim-latex not being loaded.
    " The following changes the default filetype back to 'tex':
    let g:tex_flavor='latex'

    let g:Tex_ViewRule_dvi = 'dviout.bat -GS=0'
endfunction

function s:ConfigureCscope()
    if has("cscope")
        set csto=0
        " set cst " Use of :tag invokes :cstag:
        set nocsverb
        for prefix in [
                    \"../../../../../..",
                    \"../../../../..",
                    \"../../../..",
                    \"../../..",
                    \"../..",
                    \"..",
                    \"."
                    \]
            " prefix issue: http://bit.ly/QKhlJe
            let csfile = prefix . "/" . "cscope.out"
            if filereadable(csfile)
                execute "cs add " . csfile . " " . prefix
                break
            endif
        endfor
        set csverb
    endif
    set cscopequickfix=s-,c-,d-,i-,t-,e-

    nmap <C-_>s :lcs find s <C-R>=expand("<cword>")<CR><CR>
    nmap <C-_>g :lcs find g <C-R>=expand("<cword>")<CR><CR>
    nmap <C-_>c :lcs find c <C-R>=expand("<cword>")<CR><CR>
    nmap <C-_>t :lcs find t <C-R>=expand("<cword>")<CR><CR>
    nmap <C-_>e :lcs find e <C-R>=expand("<cword>")<CR><CR>
    nmap <C-_>f :lcs find f <C-R>=expand("<cfile>")<CR><CR>
    nmap <C-_>i :lcs find i ^<C-R>=expand("<cfile>")<CR>$<CR>
    nmap <C-_>d :lcs find d <C-R>=expand("<cword>")<CR><CR>
endfunction

function s:ConfigureCoffeeScript()
    set sw=2 ts=2 smarttab expandtab autoindent
    " This needs to work with the coffeescript syntax definition in .ctags
    " file. See https://gist.github.com/puzzl3r/c2881068454d66f5d84a
    let g:tagbar_type_coffee = {
                \ 'ctagstype' : 'coffee',
                \ 'kinds'     : [
                \ 'c:classes',
                \ 'm:methods',
                \ 'f:functions',
                \ 'v:variables',
                \ 'f:fields',
                \ ]
                \ }
endfunction

function s:ConfigureMenu()
    amenu 700.100 &My.&NERDTree                 :NERDTreeToggle<CR>
    amenu 700.200 &My.&Tagbar                   :TagbarToggle<CR>
    amenu 700.300 &My.-SEP1-                    :
    amenu 700.400 &My.&Install\ new\ plugins    :PluginInstall<CR>
    amenu 700.420 &My.&Clean\ new\ plugins      :PluginClean<CR>
    amenu 700.500 &My.&Update\ all\ plugins     :PluginInstall!<CR>
    amenu 700.600 &My.-SEP2-                    :
    amenu 700.700 &My.&Copy\ file\ path         :Cpfn<CR>
    amenu 700.800 &My.&Horizontal\ Scrollbar    :Hsbar<CR>
    amenu 700.900 &My.&vimrc                    :tabnew $MYVIMRC<CR>

    if !has('gui_running')
        " Source menu.vim so :emenu can use them in non-gui environments
        so $VIMRUNTIME/menu.vim
    endif
endfunction

function s:ToggleHorizontalScrollbar()
    let index=match(&guioptions, "b")
    if index >= 0
        set guioptions-=b
    else
        set guioptions+=b
    endif
endfunction

function s:Main()

    " Map ChangeFontSize() to hot keys
    let g:mapleader = " "

    " Only enable airline indent check. Don't enable the default trailing
    " space check as it's too distracting
    let g:airline#extensions#whitespace#checks = [ 'indent' ]

    let g:airline#extensions#tabline#enabled = 1
    let g:airline#extensions#tabline#show_buffers = 1

    set sw=4 ts=4 smarttab expandtab autoindent
    set cursorline " highlight current line
    " last window will always have a status line. This is needed by vim-airline
    set laststatus=2
    set directory+=$TEMP
    set encoding=utf-8
    set nowrap " Do not wrap long lines
    set vb            " Use visual bell instead of beep
    set linebreak       " break line at word boundary
    set number          " line number
    " allow a window to shrink minimally
    set winminheight=0
    set winminwidth=0

    set foldmethod=indent
    if (has('gui_running'))
        set foldcolumn=4
    endif
    set foldminlines=0 " allow folding 1-liner
    set nofen

    set display+=lastline "with this, the last line will not have @ chars.
    set ttymouse=xterm2
    set wildmenu     " Show menu for command line autocomplete
    set ignorecase
    set smartcase

    " ------------------------- GUI settings -------------------------
    if has("gui_running")
        set go-=T
        colo solarized " this color doesn't work well under console
        call s:ConfigureFont()
        autocmd GUIEnter * winsize 100 40
    else
        colo desert
    endif
    " ------------------------- GUI settings -------------------------

    call s:ConfigureTags()
    call s:ConfigureCscope()

    " Adding 'p' for quickfix window to preview files
    if has('autocmd') && has('quickfix') 
        au BufWinEnter quickfix exe 'map <buffer> p <CR><C-W>p'
    endif 

    " Make sure we use findstr on Windows, no matter if grep is there or not

    " ------------------------- OMNI COMPLETION SETTINGS -------------------------
    if has('autocmd')

        set pumheight=8 " set completion window height
        " the following lines close the preview window after a completion
        autocmd CursorMovedI * if pumvisible() == 0|pclose|endif
        autocmd InsertLeave * if pumvisible() == 0|pclose|endif

    endif
    " ------------------------- OMNI COMPLETION SETTINGS -------------------------

    " ------------------------- KEY MAPPINGS -------------------------
    " Pressing <Leader> twice put you in command mode
    map <Leader><Leader> :
    map <Leader>tt :TagbarToggle<CR>
    map <Leader>nn :NERDTree<CR>

    " Quick escape from insert mode
    imap jj <ESC>

    " To resolve <S-Tab> conflict with snipMate
    imap <C-J> <Plug>delimitMateS-Tab
    " ------------------------- KEY MAPPINGS -------------------------

    " ------------------------- CUSTOM COMMANDS -------------------------
    " copy file name to system clipboard (verified on Windows)
    command Cpfn let @* = expand("%:p")
    command Hsbar call s:ToggleHorizontalScrollbar()
    " ------------------------- CUSTOM COMMANDS -------------------------

    " ------------------------- FILE TYPE SPECIFIC CONFIGURATIONS -------------------------
    if has('autocmd')
        autocmd FileType python call s:ConfigurePython()
        autocmd FileType cs call s:ConfigureCSharp()
        autocmd FileType tex call s:ConfigureTex()
        autocmd FileType coffee call s:ConfigureCoffeeScript()
    endif
    " ------------------------- FILE TYPE SPECIFIC CONFIGURATIONS -------------------------

    if s:IsWindows()
        set grepprg=findstr\ /N

        source $VIMRUNTIME/mswin.vim " Add support for copy/paste/cut/undo
        " Unmap windows behaviors of the following keys from mswin.vim
        unmap <C-Y>
        unmap <C-Z>
    endif

    if filereadable($HOME."/local.vim")
        exe "so $HOME"."/local.vim"
    endif

    call s:ConfigureMenu()

endfunction

call s:Main()
